#  高精度加法

https://www.acwing.com/problem/content/793/

https://www.luogu.com.cn/problem/P1601

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N 100010
int a[N], b[N], c[N]; // a加数，b加数，c是和
char A[N], B[N]; // 存储a和b的输入

// 返回a和b中的较大值
int max(int a, int b)
{
	return a > b ? a : b;
}

// c = a + b
int add(int a[], int b[], int c[], int lenc)
{
	int t = 0; // 存储一位相加的结果或向高位的进位
	for (int i = 0; i < lenc; i ++ )
	{
		t += a[i] + b[i]; // 该位相加的结果
		c[i] = t % 10; // 本位和
		t /= 10; // 向高位的进位
	}
	if (t) c[lenc] = 1, lenc ++ ; // 最高位最多进一位
	return lenc;
}

int main()
{
	scanf("%s%s", A, B); // 以字符串形式读入a和b
   
	int lena = strlen(A), lenb = strlen(B); // 得到a和b的长度
    // 倒序储存
	for (int i = lena - 1, j = 0; i >= 0; i -- , j ++ )
		a[j] = A[i] - '0';
	for (int i = lenb - 1, j = 0; i >= 0; i -- , j ++ )
		b[j] = B[i] - '0';
    // c = a + b，取两个整数中较长的长度作为和的长度
	int lenc = add(a, b, c, max(lena, lenb));
    // c也是倒序的
	for (int i = lenc - 1; i >= 0; i -- )
		printf("%d", c[i]);
	return 0;
}
```

#  高精度乘高精度

https://www.luogu.com.cn/problem/P1303

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N 100010
int a[N], b[N], c[N];
char A[N], B[N];

int mul(int a[], int b[], int c[], int lena, int lenb)
{
	int lenc = lena + lenb + 1;
	for (int i = 0; i < lena; i ++ )
		for (int j = 0; j < lenb; j ++ )
			c[i + j] += a[i] * b[j];
	for (int i = 0; i < lenc; i ++ )
		c[i + 1] += c[i] / 10, c[i] %= 10; 
	while (lenc > 1 && c[lenc - 1] == 0) lenc -- ;
	return lenc;
}

int main()
{
	scanf("%s%s", A, B);
	int lena = strlen(A);
	for (int i = lena - 1, j = 0; i >= 0; i -- , j ++ )
		a[j] = A[i] - '0';
	int lenb = strlen(B);
	for (int i = lenb - 1, j = 0; i >= 0; i -- , j ++ )
		b[j] = B[i] - '0';
	int lenc = mul(a, b, c, lena, lenb);
	for (int i = lenc - 1; i >= 0; i -- )
		printf("%d", c[i]);
	return 0;
}
```

#  高精度乘低精度

https://www.acwing.com/problem/content/795/

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N 100010
int a[N], c[N], b; // a是大数，c是积，b是较小的数
char A[N];

int mul(int a[], int b, int c[], int lena)
{
	int t = 0, lenc = lena; 
    // 从低位开始，逐位相乘
	for (int i = 0; i < lena; i ++ ) 
	{
		t += a[i] * b; 
		c[i] = t % 10; // 本位的结果
		t /= 10; // 向高位的进位
	}
	while (t) c[lenc] = t % 10, t /= 10, lenc ++ ; // 处理剩余的进位
	while (lenc > 1 && c[lenc - 1] == 0) lenc -- ; // 清除前导0
	return lenc;
}

int main()
{
	scanf("%s%d", A, &b);
	int lena = strlen(A); // 获取a的长度
    // 倒序存放
	for (int i = lena - 1, j = 0; i >= 0; i -- , j ++ )
		a[j] = A[i] - '0';
	int lenc = mul(a, b, c, lena);
	for (int i = lenc - 1; i >= 0; i -- )
		printf("%d", c[i]);
	return 0;
}
```

#  阶乘之和

https://www.luogu.com.cn/problem/P1009

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N 100010
int sum[N], a[N], ts[N], ta[N];

int max(int a, int b)
{
	return a > b ? a : b;
}

// 高精度加法
int add(int a[], int b[], int c[], int cnt)
{
	int t = 0;
	for (int i = 0; i < cnt; i ++ )
	{
		t += a[i] + b[i];
		c[i] = t % 10;
		t /= 10;
	}
	if (t) c[cnt] = 1, cnt ++ ;
	return cnt;
}

// 高精度乘低精度
int mul(int a[], int b, int c[], int lena)
{
	int t = 0, lenc = lena;
	for (int i = 0; i < lena; i ++ )
	{
		t += a[i] * b;
		c[i] = t % 10;
		t /= 10;
	}
	while (t) c[lenc] = t % 10, t /= 10, lenc ++ ;
	while (lenc > 1 && c[lenc - 1] == 0) lenc -- ;
	return lenc;
}

int main()
{
	int n;
	scanf("%d", &n);
	a[0] = 1; // 乘积初始化为1
	int lens = 0, lena = 1;
	for (int i = 1; i <= n; i ++ )
	{
        // 因为两个函数在运算过程中会改变数组的值
        // 在运算前先把a和sum复制到ta和ts中，作为运算数
        // a和sum就更新成运算的结果
		memcpy(ta, a, sizeof a); 
		memcpy(ts, sum, sizeof sum);
		lena = mul(ta, i, a, lena);
		lens = add(ts, a, sum, max(lens, lena));
	}
	for (int i = lens - 1; i >= 0; i -- )
		printf("%d", sum[i]);
	return 0;
}
```

#  高精度减法

https://www.acwing.com/problem/content/794/

https://www.luogu.com.cn/problem/P2142

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N 100010
int a[N], b[N], c[N]; // c是差
char A[N], B[N]; // 输入时存储a和b

// a>=b返回1，否则返回0
int cmp(int a[], int b[], int lena, int lenb) 
{
    // a和b都是正整数，位数多的一定比位数少的大
	if (lena != lenb) return lena > lenb; 
	else // 否则只能从高位开始比较
	{
		for (int i = lena - 1; i >= 0; i -- )
		{
			if (a[i] != b[i]) 
				return a[i] > b[i];
		}
		return 1; // 相等也返回1
	}
}
// c = a - b，a是较大的那个数
int sub(int a[], int b[], int c[], int lena, int lenb)
{
	int t = 0, lenc = lena; // t是借位或在某一位作差的结果
	for (int i = 0; i < lena; i ++ )
	{
		t = a[i] - t - b[i]; 
		c[i] = ((t % 10) + 10) % 10; // c[i]两种情况的取值合并起来写
		if (t < 0) t = 1;
		else t = 0;
	}
	while (lenc > 1 && c[lenc - 1] == 0) lenc -- ; // 清除前导0
	return lenc;
}

int main()
{
	scanf("%s%s", A, B);
	int lena = strlen(A), lenb = strlen(B);
	for (int i = lena - 1, j = 0; i >= 0; i -- , j ++ )
		a[j] = A[i] - '0';
	for (int i = lenb - 1, j = 0; i >= 0; i -- , j ++ )
		b[j] = B[i] - '0';
	int lenc;
    // 比较2个数的大小，保证是大数减小数
	if (cmp(a, b, lena, lenb)) lenc = sub(a, b, c, lena, lenb);
	else
	{
		printf("-");
		lenc = sub(b, a, c, lenb, lena);
	}
    // 倒序输出
	for (int i = lenc - 1; i >= 0; i -- )
		printf("%d", c[i]);
	return 0;
}
```

#  练习：高精度除低精度

https://www.acwing.com/problem/content/796/

https://www.luogu.com.cn/problem/P1480

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N 100010
typedef long long ll;
int a[N], c[N], b; // a是被除数，b是除数，c是商
char A[N]; // 存储输入的a

int divide(int a[], int b, int c[], int lena, int *r)
{
    /*
    洛谷最后一个点的数据
    9000000000
    1000000000
    这个数据会导致最后等于9000000000，超过了int的范围，t要用long long来存
    题目里小数<=1e9，t用long long是够的，因为大数在大于b时t就会减小了，不会超过long long
    */

	ll t = 0, lenc = 0; // lenc记录商的位数
    // 除法和其他的不同，是从高位开始算的
	for (int i = lena - 1; i >= 0; i -- )
	{
		t = t * 10 + a[i]; // 余数乘10，被除数的第i位落下来，相加，这里t用long long来存，否则过不了洛谷最后一个点
		c[lenc] = t / b, lenc ++ ; // 本位的商
		t %= b; // 新的余数
	}
    // 因为我们是从高位开始算，所以在c数组中，商是顺序存储的，为了和其他的保持一致，我们把它倒过来
	int i = 0, j = lenc - 1;
	while (i < j) 
	{
		int t = c[i];
		c[i] = c[j];
		c[j] = t;
		i ++ , j -- ;
	}
    // 去除前导0
	while (lenc > 1 && c[lenc - 1] == 0) lenc -- ;
	*r = t; // t此时就是最后的余数，赋值给r，传递回去
	return lenc;
}

int main()
{
	scanf("%s%d", A, &b);
	int lena = strlen(A);
    // 倒序存放
	for (int i = lena - 1, j = 0; i >= 0; i -- , j ++ )
		a[j] = A[i] - '0';
	int r; // 余数
    // 因为余数要改变，所以用指针传递变量
	int lenc = divide(a, b, c, lena, &r);
    // 输出商
	for (int i = lenc - 1; i >= 0; i -- )
		printf("%d", c[i]);
	printf("\n");
    // 输出余数
	// printf("%d", r);
	return 0;
}
```

#  挑战

最近刚发现的一道题，需要高精度除高精度

真的很感兴趣的同学可以尝试，我也没做过（：

https://www.luogu.com.cn/problem/P1932

